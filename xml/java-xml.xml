<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//CAFEBABE//DTD article 1.0//EN" 
                         "../dtd/article.dtd">

<article lang="fr" 
         id="java-xml" 
         date="2001-01-28" 
         email="casa@sweetohm.net" 
         author="Michel CASABIANCA"
         pdf="true">
 
 <title>Développement XML en Java sous Linux</title>

 <abstract>
  <p>Ce document présente une brève introduction à XML, les outils
   Java de développement ainsi que des exemples de mise en oeuvre de
   XML.</p>
 </abstract>

 <text>

  <p>Pour télécharger la dernière version de ce document :</p>

  <table>
   <li>
    <co>HTML</co>
    <co><link url="http://www.cafebabe.net/html/java-xml.html"/></co>
   </li>
   <li>
    <co>PDF</co>
    <co><link url="http://www.cafebabe.net/arc/java-xml.pdf"/></co>
   </li>
  </table>

  <sect><title>Introduction à XML</title>

   <sect><title>Origines</title>
    <list>
     <item>Recommandation du W3C : <link url="http://www.w3.org/TR/REC-xml"/>
     </item>
     <item>Traduction en français : <link url="http://babel.alis.com/web_ml/xml/REC-xml.fr.html"/></item>
     <item>Naissance de XML : <link url="http://java.sun.com/xml/birth_of_xml.html"/></item>
    </list>

    <p>XML (eXtensible Markup Language) est né du constat que le HTML n'est
     pas adapté aux futures exigences de l'internet. Des ingénieurs ont 
     alors eu l'idée de remplacer le HTML par SGML (Standard Generalized 
     Markup Language), seul système capable à l'époque de succéder au
     HTML.</p>

    <p>Jon Bosak, qui travaillait pour Sun, a alors été chargé par le W3C
     de "mettre le SGML sur le web". Le travail de définition de ce qui 
     allait devenir le XML (suggestion du gourou SGML James Clark) a duré
     onze semaines (de la fin août 1996 à novembre de la même année, date
     de publication du premier draft). Les finitions ont pris encore une
     année et la version 1.0 de la norme a été publiée en février 1998.</p>

    <p>L'idée du groupe de travail du W3C était de créer un langage de
     balisage hypertexte aussi simple à apprendre et utiliser que le HTML
     et aussi puissant que le SGML. C'est une démarche similaire qui a
     conduit Sun à développer Java (simplification du C++).</p>
   </sect>

   <sect><title>Caractéristiques de XML</title>
    <list>
     <item>Introduction à XML : <link url="http://www.javaworld.com/javaworld/jw-04-1999/jw-04-xml.html"/></item>
    </list>

    <p>XML reprend donc les principales caractéristiques qui font la
     puissance de SGML :</p>

    <list>
     <item>L'utilisateur est libre de créer son propre jeu de balises
      (ou <file>éléments</file>).</item>
     <item>Il en définit la syntaxe dans un fichier séparé, appelé
      <file>DTD</file> (pour Document Type Definition).</item>
     <item>Il est possible d'inclure la DTD dans l'en tête du
      fichier XML lui-même (document <file>stand alone</file>) ou même
      de créer des documents sans DTD.</item>
     <item>Un fichier XML est dit <file>bien formé</file> s'il se conforme
      à la syntaxe générale du XML (par exemple, tout élément ouvert doit
      être refermé).</item>
     <item>Un fichier XML sera dit <file>valide</file> s'il est 
      <file>bien formé</file> et est conforme à la syntaxe définie dans sa 
      DTD.</item>
    </list>
   </sect>

   <sect><title>Comparaison avec HTML</title>

    <p>Pour comprendre l'intérêt du XML, on peut le comparer au HTML qui
     a le mérite d'être connu de tous. Pour la démonstration, je prendrai
     l'exemple d'un répertoire d'adresses.</p>

    <p>Voici l'allure du fichier HTML :</p>

     <source>
  &lt;html&gt;

   &lt;head&gt;&lt;title&gt;R&amp;#233;pertoire&lt;/title&gt;&lt;/head&gt;

   &lt;body&gt;
    &lt;center&gt;&lt;h1&gt;Mon r&amp;#233;pertoire&lt;/h1&gt;&lt;/center&gt;
    &lt;h2&gt;Michel Casabianca&lt;/h2&gt;
     &lt;p&gt;Expert Java et XML (In-Fusio)&lt;/p&gt;
     &lt;p&gt;&lt;bf&gt;Adresse:&lt;/bf&gt;&lt;/p&gt;
     &lt;p&gt;23, parvis des Chartrons&lt;br&gt;
        33074 Bordeaux&lt;/p&gt;
     &lt;p&gt;Téléphone: 05.56.79.92.00&lt;/p&gt;
     &lt;p&gt;Mobile: 06.81.71.72.44&lt;/p&gt;
     &lt;p&gt;email: michelc@in-fusio.com&lt;/p&gt;
     &lt;p&gt;www: www.in-fusio.com&lt;/p&gt;
    &lt;/body&gt;

  &lt;/html&gt;
     </source>

    <p>Le moins que l'on puisse dire est que le source HTML n'est pas
     particulièrement clair !</p>
  
    <p>Voici maintenant l'allure du fichier XML :</p>
  
     <source>
  &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
  
  &lt;!DOCTYPE repertoire PUBLIC "-//CASA//DTD repertoire//FR" "repertoire.dtd"&gt;
  
  &lt;repertoire&gt;
  
   &lt;personne&gt;
     &lt;prenom&gt;Michel&lt;/prenom&gt;
     &lt;nom&gt;Casabianca&lt;/nom&gt;
     &lt;qualite&gt;Expert Java et XML&lt;/qualite&gt;
     &lt;entreprise&gt;In-Fusio&lt;/entreprise&gt;
     &lt;adresse lieu="travail"&gt;
       &lt;rue&gt;23, parvis des Chartrons&lt;/rue&gt;
       &lt;cp&gt;33074&lt;/cp&gt;
       &lt;ville&gt;Bordeaux&lt;/ville&gt;
       &lt;pays&gt;France&lt;/pays&gt;
       &lt;telephone&gt;05.56.79.92.00&lt;/telephone&gt;
       &lt;mobile&gt;06.81.71.72.44&lt;/mobile&gt;
       &lt;email&gt;michelc@in-fusio.com&lt;/email&gt;
       &lt;www&gt;www.in-fusio.com&lt;/www&gt;
     &lt;/adresse&gt;
   &lt;/personne&gt;
  
  &lt;/repertoire&gt;
     </source>

    <p>Ce source XML contient les mêmes informations, mais il présente les
     avantages suivants :</p>

    <list>
     <item>Il ne mélange pas l'<file>information</file> contenue dans le
      document et sa <file>présentation</file> comme le fait le HTML. 
      Par exemple, l'élément &lt;title&gt; du HTML contient de l'information
      exploitable alors que l'élément &lt;center&gt; ne sert qu'à indiquer
      une mise en forme. La rédaction du contenu et sa mise en forme
      correspondant à deux métiers différents, il n'est pas logique de
      les mélanger.</item>
     <item>Cette séparation du contenu et de la forme permet 
      d'<file>extraire</file> des informations du document. Une application
      peut en effet faire une liste des entrées du répertoire (pour
      les injecter dans une base de données par exemple) si elle sait
      que le nom d'une personne est encadré par un élément &lt;nom&gt;, son
      prénom par un élément &lt;prenom&gt;, etc. Cette tâche peut être
      réalisée de manière <file>fiable</file> et <file>standard</file> par
      un <file>parser</file> XML.</item>
    </list>

   </sect>

   <sect><title>Document Type Definitions</title>

    <p>On peut fixer la grammaire d'un type de document
     à l'aide d'une DTD (pour Document Type Definition). Celle de
     notre exemple de répertoire permet d'imposer que toute entrée
     comporte un nom et un prénom, une qualité, etc. Pour notre
     répertoire, cette DTD pourrait ressembler à la suivante:</p>

     <source>
  &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;

  &lt;!ENTITY % lieux "travail | domicile | vacances"&gt;

  &lt;!ELEMENT repertoire (personne+)&gt;

  &lt;!ELEMENT personne (prenom, nom, qualite, entreprise, adresse+)&gt;

  &lt;!ELEMENT prenom (#PCDATA)&gt;
  &lt;!ELEMENT nom (#PCDATA)&gt;
  &lt;!ELEMENT qualite (#PCDATA)&gt;
  &lt;!ELEMENT entreprise (#PCDATA)&gt;

  &lt;!ELEMENT adresse (rue, cp, ville, pays, telephone, mobile?, email?, www?)&gt;
  &lt;!ATTLIST adresse lieu (%lieux;) "travail"&gt;

  &lt;!ELEMENT rue (#PCDATA)&gt;
  &lt;!ELEMENT cp (#PCDATA)&gt;
  &lt;!ELEMENT ville (#PCDATA)&gt;
  &lt;!ELEMENT pays (#PCDATA)&gt;
  &lt;!ELEMENT telephone (#PCDATA)&gt;
  &lt;!ELEMENT mobile (#PCDATA)&gt;
  &lt;!ELEMENT email (#PCDATA)&gt;
  &lt;!ELEMENT www (#PCDATA)&gt;

     </source>

    <p>Un document muni d'une DTD peut être <file>validé</file> ce qui 
     certifie qu'il est conforme à son type. Les DTDs du standard
     sont cependant relativement pauvres (on ne peut par exemple
     pas imposer qu'un champ soit un nombre entier). Pour aller
     plus loin, on peut utiliser <file>Schema</file> qui propose des
     conditions beaucoup plus fines pour les types de document.</p>

   </sect>

   <sect><title>Feuilles de style</title>
    <list>
     <item>Introduction à XSL : 
      <link url="http://metalab.unc.edu/xml/books/bible/updates/14.html"/>
     </item>
    </list>

    <p>Bien sûr, on peut se poser la question de savoir comment on
     peut visualiser un fichier XML dans la mesure où les balises ne
     donnent aucune indication sur la présentation du document. Pour
     pouvoir afficher un fichier XML, il faut donc lui associer une
     <file>feuille de style</file>. Celle-ci permet de le transformer en
     un document (HTML ou autre) que l'on peut afficher.</p>

    <figure url="java-xml.xslt.png" width="10">
     <title>Transformation XSLT</title>
    </figure>

    <p>XSLT (eXtensible Style Language, Transformation) est un standard 
     du W3C permettant de <file>transformer</file> un fichier XML en un autre
     fichier, XML ou d'un autre format (HTML, PDF ou Texte par exemple). 
     Un fichier XSL est lui-même un fichier XML opérant une transformation
     sur l'<file>arbre</file> du document XML.</p>

    <p>Une feuille de style XSLT est essentiellement constituée de
     <file>templates</file>. Un template transforme un élément XML en
     un texte quelconque dans le document résultant (par exemple en
     un tag HTML). Pour transformer un nom de notre répertoire en
     un tag &lt;h2&gt;, nous pourrions définir le template suivant:</p>

     <source>
  &lt;xsl:template match="nom"&gt;
    &lt;h2&gt;&lt;xsl:apply-templates/&gt;&lt;/h2&gt;
  &lt;/xsl:template&gt;
      </source>

    <p>On aura compris que la modification de la <file>présentation</file> de la
     page n'implique que la modification de la feuille de style (et
     non de chaque fichier HTML, ce qui peut devenir un cauchemar pour
     de gros sites).</p>

    <p>XSLT va cependant plus loin que d'autres langages de feuille de
     style (comme CSS) car il permet de manipuler la <file>structure</file>
     du document. On peut ainsi générer automatiquement un index
     de notre répertoire et le trier par ordre alphabétique par nom ou
     entreprise par exemple.</p>

    <p>On peut aussi transformer un fichier XML de type <file>A</file> en un
     document de type <file>B</file>, passant ainsi d'une DTD à une autre 
     (si les informations sont compatibles). XSLT est donc aussi un
     langage de transformation entre DTD.</p>

   </sect>

   <sect><title>Échange de données textuelles entre programmes</title>

    <p>XML va beaucoup plus loin que HTML car son champ d'application
     ne se borne pas aux documents texte. Du fait que l'on peut y
     extraire des informations de façon fiable, il permet l'échange
     d'information entre programmes.</p>

    <p>Cette utilisation de XML a de beaux jours devant elle car un
     fichier XML présente de nombreux avantages sur un fichier binaire
     ou texte "plat":</p>

    <list>
     <item>Il est indépendant de la plateforme (il utilise l'encodage
      Unicode pour les caractères).</item>
     <item>Il est indépendant du langage de programmation.</item>
     <item>Il est manipulable par un simple éditeur de texte.</item>
     <item>Les outils pour le manipuler sont standards (les parsers
      XML sont légions et on en trouve pour quasiment tous les
      langages de programmation).</item>
    </list>

    <p>Par exemple, XML-RPC permet d'appeler des méthodes sur une machine
     distante grâce à un protocole utilisant XML. Il présente, par 
     rapport à RMI par exemple, l'avantage d'être indépendant du
     langage (alors que RMI est lié à Java) et de la plateforme.</p>

    <p>XML est très utilisé comme format de données textuelles,
     voir les exemples de mise en oeuvre à la fin de cet article
     pour des applications concrètes.</p>

   </sect>

   <sect><title>Standards dérivés</title>
    <list>
     <item>Liste de spécifications XML : <link url="http://www.xml.org/xmlorg_registry/index.shtml"/>
     </item>
    </list>

    <p>Un intérêt de XML est donc l'échange d'informations. Pour que cet
     échange soit possible, il faut que les acteurs d'un secteur se
     mettent d'accord sur une DTD commune.</p>

    <p>On voit donc émerger quotidiennement de nouvelles spécifications
     pour toutes sortes de domaines d'activité (allant de la notation
     musicale au commerce électronique).</p>

    <p>Il a ainsi été définit un standard pour la notation de formules
     mathématiques : <link url="http://www.w3.org/TR/REC-MathML/"/>. IBM propose un 
     <link url="http://www.software.ibm.com/network/techexplorer/"/> pour visualiser des formules
     écrites dans ce format et Amaya permet de les visualiser depuis peu.</p>

    <p>Cependant, il risque d'apparaître un problème : celui de la
     multiplication des DTD concurrentes nuisant à toute standardisation
     (voir l'article <link url="http://www.xmltechno.com/focus/2000_08_28_standards/standards_xml_p1.cfm"/>).
     On peut néanmoins espérer que l'on remédie à cette situation, pour
     plusieurs raisons :</p>

    <list>
     <item>XSLT permet de convertir un document vers une autre DTD. Si
      les informations contenues dans les documents sont semblables, la
      conversion devrait être possible dans la plupart des cas (seule
      l'expérience nous le dira).</item>
     <item>Il est très probable qu'une sélection s'opère rapidement
      et qu'il ne reste qu'un seul format dans chaque domaine d'activité
      (ou un petit nombre de formats inter-opérables).
     </item>
    </list>

    <p>C'est à mon sens le seul nuage assombrissant l'avenir de XML.</p>

   </sect>

   <sect><title>APIs</title>

    <p>Le langage XML étant un standard, il permet l'échange d'informations
     entre applications. L'étape suivante est en toute logique la 
     standardisation de l'API des parsers (composants logiciels permettant
     d'accéder facilement aux données contenues dans un document XML). 
     C'est le but de SAX (Simple API for XML) et de DOM (Document Object 
     Model).</p>

    <sect><title>SAX</title>
     <list>
      <item>Norme SAX : <link url="http://www.megginson.com/SAX/index.html"/>
      </item>
     </list>

     <p>Le principe du parser SAX est simple : on lui raccorde des objets
      dont les méthodes (implantant des interfaces précises) sont appelées
      par le parser lorsque certains évènements se produisent au cours du
      parsing du fichier XML.</p>

     <p>La norme SAX (en version 2) définit ainsi quatre interfaces :</p>
     <list>
      <item><imp>ContentHandler :</imp> le parser appelle ses méthodes pour
       rendre compte des évènements relatifs au document. Elle définit ,
       entre autre, les méthodes suivantes :</item>
      <list>
       <item><code>startDocument() :</code> lorsqu'il ouvre un nouveau document
       </item>
       <item><code>startElement() :</code> lorsqu'il rencontre un nouvel élément
       </item>
       <item><code>characters() :</code> lorsqu'il rencontre du texte</item>
      </list>

      <item><imp>ErrorHandler :</imp> ses méthodes sont appelées lorsque le
       parser rencontre des warnings ou des erreurs. Elle permet par
       conséquent au développeur de décider de l'attitude à adopter
       en cas d'erreur (arrêter le parsing ou non).</item>

      <item><imp>DTDHandler :</imp> ses méthodes sont appelées lors du
       parsing de la DTD du document.</item>

      <item><imp>EntityResolver :</imp> son unique méthode 
       <code>resolveEntity()</code> renvoie une URL pour une URI donnée. Utile
       pour la gestion des catalogues par exemple.</item>
     </list>

     <p>SAX est très rapide et peu gourmand en mémoire, mais il ne permet
      pas de manipuler l'arbre du document lors du parsing (il ne fait 
      que <file>consommer</file> les données). La norme permet d'écrire des
      applications indépendantes du parser utilisé (en prenant quelques
      précautions décrites plus loin dans ce document).</p>

    </sect>
    <sect><title>DOM</title>
     <list>
      <item>Standard du W3C : <link url="http://www.w3.org/TR/DOM-Level-2-Core/"/>
      </item>
     </list>

     <p>DOM (Document Object Model) permet de représenter un document
      XML sous forme d'un arbre d'objets en mémoire. Il définit
      une API pour parcourir et modifier l'arborescence.</p>

     <p>DOM est donc tout indiqué pour des applications modifiant
      l'arbre du document (comme un éditeur graphique de fichiers XML).
     </p>

     <p>Cependant, DOM soufre d'un certain nombre de défauts :</p>
     <list>
      <item><imp>Il est lent :</imp> à tel point que la plupart des 
       processeurs XSLT (qui pourtant seraient une application toute
       indiquée du DOM) implantent leur propre modèle objet en mémoire.</item>
      <item><imp>Il est gourmand en mémoire :</imp> chaque noeud (y compris
       ceux d'attributs et de blancs) contient une référence vers le noeud
       parent, suivant, précédent, premier et dernier fils, document
       le contenant, son nom, sa valeur, données utilisateur et quelques
       drapeaux.</item>
      <item><imp>La norme est incomplète :</imp> elle ne définit pas,
       entre autre, comment on récupère le document. Chaque parser implante
       donc sa propre API. Il est par conséquent impossible d'écrire du code
       indépendant du parser utilisé. On est amené à écrire des classes
       "wrapper" implantant une interface commune pour chaque parser
       supporté (on pourra par exemple consulter le code source du
       processeur XSLT XSL:P).</item>
     </list>

    </sect>

    <sect><title>Java API for XML Parsing</title>

     <list>
      <item><link url="http://java.sun.com/aboutJava/communityprocess/final/jsr005/index.html"/></item>
     </list>

     <p>Sun a mis au point l'API pour le parsing XML afin de résoudre les
      problèmes de dépendance du code au parser évoqués ci-dessus.
      Son API est une enveloppe pour rendre le code d'une application XML
      indépendante du parser utilisé. Elle encapsule la création et le
      paramétrage des parsers SAX et DOM.</p>

     <p>Par exemple, pour créer un parser SAX validant et implantant les
      espaces de nommage, on utilisera le code suivant :</p>

<source>
  SAXParser parser;
  HandlerBase handler = new MyHandlerBase();
  SAXParserFactory factory = SAXParserFactory.newInstance();
  factory.setNamespaceAware(true);
  factory.setValidating(true);
  try {
    parser = factory.newSAXParser();
    parser.parse("http://monserveur/mondocument.xml", handler);
  } catch(SAXException se) {
    // gestion des erreurs
  } catch(IOException ioe) {
    // gestion des erreurs
  } catch(ParserConfigurationException pce) {
    // gestion des erreurs
  }
</source>

     <p>Ce code est totalement indépendant du parser utilisé et fonctionnera
      avec tout parser conforme à l'API JAXP. JAXP définit aussi un mécanisme
      semblable pour instancier et paramétrer un parser DOM.</p>

     <p>Le parser de Sun et les principaux parsers XML en Java implantent
      cette API et il est très probable que tous les autres fournisseurs
      suivent cet exemple.</p>

    </sect>
   </sect>
  </sect>

  <sect><title>Outils pour XML</title>

   <p>Je vous propose maintenant de faire un tour d'horizon des
    <file>principaux</file> outils XML tournant sur plateforme Linux (pour
    l'essentiel des outils Java). Un tel référencement ne peut prétendre être
    exhaustif car le nombre d'outils disponible est très important et
    augmente sans cesse. Pour des listes exhaustives et régulièrement
    mises à jour, on pourra consulter la page 
    <link url="http://www.stud.ifi.uio.no/~lmariusg/linker/XMLtools.html"/> (concernant exclusivement les outils libres) ou
    encore le site <link url="http://www.xml.com/resourceguide"/> 
    qui recense aussi les outils propriétaires. D'autre part, l'article
    <link url="http://www.xmltechno.com/outils/01_intro_p1.cfm"/> recense les principaux
    outils XML pour l'ensemble des langages de programmation et des
    plateformes.</p>

   <sect><title>Le projet xml.apache.org</title>
    <list>
     <item><link url="http://xml.apache.org"/></item>
     <item>Articles : 
      <link url="http://xml.apache.org/pr/0001.txt"/> et 
      <link url="http://news.cnet.com/news/0-1003-200-1431504.html?tag=st.ne.1002.thed.1003-200-1431504"/>
     </item>
    </list>
    <p>Le projet <file>xml.apache.org</file> a pour objectif de fournir
     des solutions XML de qualité en Open Source, de faire suivre les
     observations concernant les standards de l'IETF et du W3C et de
     regrouper les activités relatives à XML du projet Apache. Il
     regroupe de nombreuses entreprises actives dans le domaine (dont
     IBM, Lotus, Sun, Exoffice et Bowstreet) et gère les sous-projets
     suivants :</p>

    <list>
     <item>Xerces : Parsers XML en Java, C++ et Perl (anciennement XML4J 
      d'IBM)</item>
     <item>Xalan : Processeurs de feuilles de style XSLT (anciennement 
      LotusXSL de Lotus)</item>
     <item>Cocoon : Système de publication sur le web basé sur XML</item>
     <item>FOP : Objets de formatage XSL</item>
     <item>Xang: Serveur d'applications Web écrites en Java utilisant XML,
      XSLT et ECMAScript (Java Script)</item>
     <item>SOAP: (Simple Object Access Protocol) est une implémentation
      <link url="http://www.w3.org/TR/SOAP"/> 
      du W3 d'un protocole d'appel de méthodes sur un objet distant
      utilisant un protocole basé sur XML.</item>
     <item>Batik: est une boite à outil Java pour la visualisation, la 
      manipulation et la génération d'images SVG (Scalable Vector
      Graphics).</item>
     <item>Crimson: est le successeur du parser de Sun Project X. Il
      devrait à terme fusionner avec Xerces pour devenir Xerces Java.</item>
    </list>

    <p>Ce projet est une avancée majeure vers l'acceptation large des 
     logiciels Open Source. Il concrétise l'engagement de grandes sociétés 
     informatiques sur la voie du logiciel libre.</p>

    <p>Le développement de ces outils est 
     <link url="http://xml.apache.org/overview.html"/>. 
     Xml.apache.org met à disposition des utilisateurs et développeurs des 
     <link url="http://xml.apache.org/mail.html"/>.
    </p>
   </sect>

   <sect><title>Parsers XML</title>

    <p>Un parser est un composant logiciel (classes Java en l'occurrence) 
     permettant d'accéder simplement aux données encapsulées dans un fichier 
     XML. C'est donc le composant de base de toute application XML.</p>

    <p>SAX permet de produire du code standard qui s'adapte, sans 
     recompilation, à tout parser moyennant quelques efforts. En particulier,
     on prendra soin de ne pas instancier directement le parser, mais de
     passer par la classe dédiée (<code>XMLReaderFactory</code>). D'autre
     part, il est utile de donner la possibilité de paramétrer le nom
     de la classe du parser (sur la ligne de commande ou dans un fichier
     de configuration).</p>

    <p>JAXP (Java API for XML Parsing), API définie par Sun pour les
     parsers XML en Java permet d'écrire du code indépendant du
     parser utilisé pourvu qu'il soit conforme à l'API. C'est très
     utile pour instancier les parsers DOM dont le standard ne définit
     que l'API pour la manipulation des documents et non pour obtenir
     le parser lui même, ce qui conduit à des codes fortement liés
     au parser utilisé. Un changement de parser en cours de projet
     peut se révéler alors douloureux.</p>

    <p>Moyennant ces quelques précautions, on pourra suivre le rythme 
     effréné du développement des parsers XML et en changer si nécessaire.
     Tous les parsers récents respectent l'API du Sun.</p>

    <sect><title>Project X de Sun</title>
     <list>
      <item><link url="http://java.sun.com/xml"/>
      </item>
      <item>Gratuit</item>
     </list>

     <p>Ce logiciel est gratuit (même pour un usage commercial), et ses
      sources en sont disponibles (dans le répertoire <file>src</file>).</p>

     <p>Le parser de Sun est conforme à XML 1.0, SAX 1.0 et DOM level 1 et 
      implante la version actuelle de XML Namespaces. Il peut tourner sur 
      toute machine virtuelle Java 1.1.6 ou supérieure.</p>

     <p>Sun met à notre disposition deux parsers : un parser non validant 
      <file>com.sun.xml.parser.Parser</file> (plus rapide) et un parser 
      validant <file>com.sun.xml.parser.ValidatingParser</file>. Le parser 
      non validant vérifie que le document est <file>bien formé</file> alors 
      que le parser validant vérifie en plus qu'il est conforme à sa DTD.</p>

     <p>En plus des standards SAX et DOM, Sun fournit des classes étendant 
      SAX pour implanter les <file>Namespaces</file>, mais aussi d'autres 
      classes utilitaires, comme le <file>TreeWalker</file> permettant de 
      naviguer aisément dans l'arbre du document.</p>

     <p>Le parser de Sun délivre des messages d'erreur particulièrement 
      clairs. On notera cependant qu'il faut lui indiquer la <file>Locale</file> 
      <file>en_US</file> pour ne pas obtenir des messages d'erreur 
      incompréhensibles.</p>

     <p>Sans préciser la <file>Locale</file>, on obtient par exemple :</p>

     <source>
      com.sun.xml.parser/V-037 fixes
     </source>

     <p>En indiquant la <file>Locale</file>, on obtient :</p>

     <source>
      Element "fixes" does not allow text.
     </source>

     <p>Ce qui est tout de même plus clair ! Le problème vient du fait 
      que la méthode d'initialisation du parser 
      (<file>com.sun.xml.Parser.init()</file>) choisit comme <file>Locale</file> 
      la <file>Locale</file> par défaut de la VM (<file>fr_FR</file> pour une 
      VM sous nos latitudes) qui n'est pas supportée. On pourra indiquer 
      la <file>Locale</file> <file>en_US</file> avec le code suivant :</p>

     <source>
      try {parser.setLocale(new Locale("en","US"));}
      catch(Exception e){}
     </source>

     <p>On trouvera <link url="http://www.sweetohm.com/html/projectx.html"/> le code pour corriger ce bug ainsi
      que la traduction des messages d'erreur en Français.</p>

     <p>La documentation du parser fournit de nombreux exemples 
      d'utilisation (dans le sous-répertoire <file>examples</file>).</p>

     <p>Mis à part ce problème, ce parser m'a semblé très fiable à 
      l'utilisation.</p>

     <p>Sun a donné son parser au projet <file>xml.apache.org</file>, qui
      devrait à terme le faire fusionner avec le parser d'IBM (voir l'
      <link url="http://xml.apache.org/pr/0001.txt"/> pour plus d'informations). Il sera bientôt
      disponible à l'URL suivante : <link url="http://xml.apache.org"/>.</p>
    </sect>

    <sect><title>Xerces-J (anciennement XML for Java) du projet xml.apache.org</title>
     <list>
      <item><link url="http://xml.apache.org/xerces-j"/> ou <link url="http://www.alphaworks.ibm.com/aw.nsf/frame?ReadForm&amp;/aw.nsf/techmain/F62DB5F8684DCF6A8825671B00682F34"/>
      </item>
      <item>Licence Apache 1.1 (pour les classes du paquet 
       <file>org.apache</file>) et IBM XML4J Evaluation Licence (pour les 
       classes du paquet <file>com.ibm</file>)</item>
     </list>

     <p>Xerces-J est le nom du projet XML4J depuis qu'IBM en a fait 
      don à <file>xml.apache.org</file>. Il est maintenant géré par ce 
      dernier mais IBM continue de distribuer une version sur son site 
      <link url="http://alphaworks.ibm.com/formula"/>. 
      La version 3 de XML4J est basée sur le code de Xerces-J mais XML4J 
      fournit en plus une API de compatibilité avec les versions 2 
      (contenue dans le fichier <code>xml4j.jar</code>).</p>

     <p>Xerces-J est distribué sous forme de binaires (fichier JAR) et 
      sous forme de sources.</p>

     <p>Xerces-J supporte <file>SAX</file> versions 1 et 2, <file>DOM</file> 
      versions 1 et 2, ainsi que <file>XML Schema</file>. Le support de 
      Schema, SAX 2 et DOM 2 est encore en développement. Il implémente 
      d'autre part l'API JAXP de Sun pour les parsers XML.</p>

     <p>Xerces-J propose deux parsers : 
      <file>org.apache.xerces.parsers.SAXParser</file> et 
      <file>org.apache.xerces.parsers.DOMParser</file>. Il est possible de 
      leur passer des <file>propriétés</file> ou des <file>fonctionnalités</file> 
      à l'aide de l'interface <file>org.xml.sax.Configurable</file> de SAX2. 
      Par exemple, pour que le parser soit validant, on pourra écrire :</p>

     <source>
      SAXParser p=new SAXParser();
      try {
        p.setFeature("http://xml.org/sax/features/validation",true);
      } catch (SAXException e) {
        System.out.println("error in setting up parser feature");
      }
     </source>

     <p>Xerces-J gère les catalogues au format <link url="http://www.ccil.org/~cowan/XML/XCatalog.html"/> 
      (version 0.2) dérivé du format de catalogue 
      <file>SGML Open catalog format</file>. Cette fonctionnalité me 
      semble quasiment indispensable pour gérer les DTDs. Pour plus 
      de détails, voir les fichiers 
      <file>org.apache.xerces.readers.XCatalog.java</file> et 
      <file>org.apache.xerces.readers.XMLCatalog.java</file> des sources.</p>

     <p>Des exemples sont disponibles dans le sous-répertoire 
      <file>samples</file>.</p>

     <p>Ce parser (dans ses versions 1 et 2) m'a donné entière 
      satisfaction, mais on peut lui reprocher ses messages d'erreur 
      pas toujours très clairs.</p>
    </sect>

    <sect><title>OpenXML</title>
     <list>
      <item><link url="http://www.openxml.org"/></item>
      <item><link url="http://www.openxml.org/license.html"/>
      </item>
     </list>

     <p>OpenXML (de Exoffice et Assaf Arkin) a longtemps été le seul 
      parser XML en Open Source. Il a rejoint le projet 
      <file>xml.apache.org</file>, mais n'est pas encore disponible sur 
      le site Apache.</p>

     <p>Il supporte XML 1.0, SAX et DOM level 1, ainsi que les catalogues 
      au format XCatalog (version 0.3) et XML Software Autoupdate.</p>

    </sect>

    <sect><title>Aelfred</title>
     <list>
      <item><link url="http://www.opentext.com/services/content_management_services/xml_sgml_solutions.html#aelfred_and_sax"/></item>
      <item>Gratuit</item>
     </list>

     <p>Ælfred est un analyseur très petit (le fichier Jar ne fait que
      22 ko), ce qui le rend très intéressant pour un usage dans
      les applets par exemple. De plus, son occupation mémoire est 
      très faible.</p>

    </sect>
    
    <sect><title>Choix d'un parser</title>
     
     <p>Le parser étant la pièce maîtresse d'une application XML, faire 
      le bon choix est primordial. On peut trouver des benchmarks testant 
      les principaux parsers disponibles :</p>

     <list>
      <item><link url="http://developerlife.com/domconformance/default.htm"/> : teste la conformité des parsers aux 
       standards</item>
      <item><link url="http://developerlife.com/parsertest2/performance.html"/> : compare les performances des trois 
       parsers Java principaux (Xerces, ProjectX et OpenXML)</item>
      <item><link url="http://www.xml.com/lpt/a/Benchmark/exec.html"/> : teste les performances des parsers dans différents langages 
       (C, Java, Perl et Python).</item>
     </list>

     <p><file>D'après ces benchmarks</file> il semblerait que :</p>
     <list>
      <item>Xerces-J soit le plus rapide</item>
      <item>ProjectX soit plus respectueux des standards</item>
     </list>

     <p><imp>Cependant</imp>, ces tests commencent à dater et j'accorde 
      personnellement peu de crédit aux benchmarks en général.
      Il ressort de mon <imp>expérience personnelle</imp> (ayant utilisé 
      de manière intensive XML4J en versions 1 et 2 et ProjectX) que :</p>
     <list>
      <item>XML4J est plus rapide sur des machines virtuelles 1.1 alors 
       que ProjectX est plus rapide sur 1.2.</item>
      <item>Les messages d'erreur de ProjectX sont plus clairs.</item>
     </list>

     <p>En outre, en produisant du code conforme aux standards, il est 
      possible de changer de parser de manière simple. La meilleure solution 
      me semble donc être de tester soi-même les parsers dans l'application.
     </p>

    </sect>

   </sect>

   <sect><title>Processeurs XSLT</title>

    <p>Les processeurs XSL transforment un fichier XML en un fichier d'un 
     autre format (html, texte ou LaTeX par exemple) à l'aide de feuilles 
     de style XSL. Ils peuvent donc être invoqués sur la ligne de commande 
     de la manière suivante :</p>

    <source>
     java classe.du.processeur fichier.xml fichier.xsl fichier.???
    </source>

    <p>Lorsqu'on utilise ces programmes pour traiter de petits fichiers sur 
     la ligne de commande, il peut être utile (pour une question de vitesse 
     d'exécution) de désactiver le compilateur JIT en ajoutant la ligne 
     suivante dans le script de lancement :</p>

    <source>
     export JAVA_COMPILER=
    </source>

    <p>Il est possible d'intégrer ces programmes dans une application. 
     Il n'existe pas d'API commune à ces processeurs, mais tous utilisent 
     un parser SAX ou DOM pour construire une représentation en mémoire 
     du document. Le document à traiter pourra alors être communiqué au 
     programme sous forme d'un DOM ou d'une <code>InputSource</code> SAX.</p>

    <sect><title>XT de James Clark</title>
     <list>
      <item><link url="http://www.jclark.com/xml/xt.html"/></item>
      <item>Licence de type Apache</item>
     </list>

     <p>Ce programme est sous licence de type <file>Open Source</file> et 
      donc livré avec celles-ci. Cependant, l'absence totale de commentaires 
      rend le code assez imperméable à toute modification ou amélioration.</p>

     <p>XT utilise un parser SAX pour lire les fichiers XML et XSL. Tout 
      parser conforme au standard fait l'affaire. On peut lui passer le nom 
      de la classe du parser sur la ligne de commande (sous forme d'une 
      propriété système, <code>-Dorg.xml.sax.parser=le.nom.du.parser</code>).</p>

     <p>Il est possible de passer des arguments sur la ligne de commande 
      (sous la forme <file>nom=valeur</file>). Ces arguments, de type chaîne 
      de caractères, peuvent alors être utilisés dans le fichier XSL s'il 
      définit le paramètre correspondant.</p>

     <p>XT peut être utilisé comme Servlet (avec un moteur de Servlet de 
      version 2.1 ou supérieur), la classe correspondante est 
      <code>com.jclark.xsl.sax.XSLServlet</code>.</p>

     <p>XT définit une API basée sur SAX (interface 
      <code>com.jclark.xsl.sax.XSLProcessor</code>) et une API basée sur DOM 
      (interface <code>com.jclark.xsl.dom.TransformEngine</code>). Cependant, 
      la classe DOM est bien plus lente et moins fonctionnelle que celle 
      basée sur SAX mais indispensable lorsque le document à traiter résulte 
      de la manipulation d'un document DOM en mémoire. Il est même possible 
      de mélanger ces deux méthodes.</p>

     <p>XT comporte quelques extensions par rapport à la norme, parmi 
      lesquelles :</p>
     <list>
      <item><imp>Appel de méthodes</imp> Java. On pourra par exemple écrire 
       le code suivant dans un fichier XSL pour afficher la date :</item>
     </list>
     <source>
    &lt;xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:date="http://www.jclark.com/xt/java/java.util.Date"&gt;

    &lt;xsl:template match="/"&gt;
    &lt;html&gt;
    &lt;xsl:if test="function-available('date:to-string') and 
    function-available('date:new')"&gt;
    &lt;p&gt;&lt;xsl:value-of select="date:to-string(date:new())"/&gt;&lt;/p&gt;
    &lt;/xsl:if&gt;
    &lt;/html&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
     </source>
     <list>
      <item><imp>Documents multiples</imp> : le fragment de document encadré 
       par l'élément <code>&lt;xt:document href="chemin-fichier"&gt;</code> sera 
       enregistré dans le fichier dont le chemin relatif (par rapport au 
       document généré) est donné par l'attribut <code>href</code>. Par exemple, 
       le source suivant génère (en plus du document normalement généré par 
       le traitement du fichier XML en cours) deux fichiers : 
       <file>hello.xml</file> (contenant la chaîne <file>Hello !</file>) et 
       <file>world.xml</file> (contenant le chaîne à laquelle vous pensez). 
       Le répertoire <file>demo</file> contient des exemples plus pertinents 
       de documents multifichiers.</item>
     </list>
     <source>
    &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xt="http://www.jclark.com/xt"
    extension-element-prefixes="xt"&gt;

    &lt;xsl:template match="/"&gt;
    &lt;xt:document method="xml" href="hello.xml"&gt;
    Hello !
    &lt;/xt:document&gt;
    &lt;xt:document method="xml" href="world.xml"&gt;
    World !
    &lt;/xt:document&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
     </source>
     <list>
      <item><imp>Méthode de sortie additionnelle :</imp> permet de rajouter 
       un caractère d'échappement devant certains caractères.</item>
      <item><imp>Fonctions additionnelles :</imp> ajoute trois fonctions à 
       celles du standard : <file>xt:node-set</file> (pour convertir un fragment 
       d'arbre en <file>node-set</file>), <file>xt:intersection</file> (renvoie 
       l'intersection de deux <file>node-sets</file>) et <file>xt:difference</file> 
       (renvoie la différence de deux <file>node-sets</file>).</item>
     </list>

     <p>Ces extensions à la norme s'avèrent être très utiles (en particulier 
      les deux premières) et l'on peut s'attendre à ce qu'elles soient un 
      jour ajoutées au standard (dans la mesure où James Clark est partie 
      prenante dans la définition de ces standards du W3C). Cependant, comme 
      toute extension, elles interdisent toute migration vers un autre 
      processeur XSL.</p>

     <p>Malgré quelques limitations (fonctionnalités de la proposition XSLT 
      1.0 non implantées) et quelques bugs connus, ce programme est très 
      fonctionnel, respectueux des standards et rapide. On regrettera
      cependant le manque de messages d'erreur qui rend le débuggage
      de fichiers XSL pénible et l'absence de commentaires dans les 
      sources.</p>

     <p>Contre toute attente, son auteur James Clark, en a arrêté le
      développement car son implémentation n'avait pour but que de
      tester la recommandation du W3 (dont il est l'éditeur). Des
      utilisateurs de XT ont cependant mis en place un site de
      <link url="http://4xt.org"/>.</p>

    </sect>

    <sect><title>Xalan-Java (anciennement LotusXSL) du projet xml.apache.org</title>
     <list>
      <item><link url="http://xml.apache.org/xalan"/></item>
      <item><link url="http://xml.apache.org/dist/LICENSE.txt"/></item>
     </list>

     <p>Xalan fait maintenant partie du projet <file>xml.apache.org</file>. Une 
      version C++ est aussi disponible.</p>

     <p>Par défaut, Xalan est configuré pour fonctionner avec Xerces, mais il 
      peut s'accommoder de tout parser DOM.</p>

     <p>Xalan peut produire des événements SAX, un DOM ou un document XML.</p>

     <p>Les feuilles de style sont lues par un parser SAX puis compilées (les 
      expressions XPath et les traitements qui peuvent l'être sans connaître 
      la structure du document XML à traiter).</p>

     <p>Il est nécessaire de créer une instance de Xalan par thread (deux 
      threads ne peuvent partager la même instance). C'est certainement peu 
      gênant pour la plupart des utilisations, mais je me demande si ce ne 
      serait pas un problème pour les <file>Servlets</file> (on ne peut alors 
      utiliser une même instance pour toutes les requêtes).</p>

     <p>Xalan permet de générer plusieurs fichiers à partir d'un unique 
      fichier XSL lorsque la méthode de sortie est <file>html</file>, <file>xml</file>
      ou <file>text</file>.</p>

     <p>Xalan permet d'appeler une méthode Java ou JavaScript dans un script 
      XSL.</p>

     <p>Le point fort de Xalan est le débuggage des fichiers XSL :</p>
     <list>
      <item>On peut tracer les <file>templates</file> en cours de génération.
      </item>
      <item>Une DTD est fournie pour les sorties de type <file>html</file>.</item>
     </list>

     <p>Il est possible d'utiliser Xalan de trois manières distinctes :</p>
     <list>
      <item><imp>Sur la ligne de commande :</imp> en lançant la classe 
       <code>org.apache.xalan.xslt.Process</code> et en lui passant le fichier 
       XML, le fichier XSL et le fichier de sortie. La liste des options de 
       la ligne de commande est très complète : on peut valider les fichiers 
       XML et XSL, on peut passer des arguments à la feuille de style, etc.
      </item>
      <item><imp>Depuis une autre classe Java :</imp> les fichiers XML et XSL 
       peuvent être passés sous forme d'<file>URL</file>, de fichier, de flux de 
       caractères ou de document DOM. La feuille de style peut être passée 
       sous forme compilée. Xalan utilise des <file>wrappers</file> pour combler 
       des lacunes de DOM concernant l'interface des parsers (le code est 
       ainsi indépendant du parser DOM utilisé). La documentation fournit un 
       exemple de programme utilisant Xalan.</item>
      <item><imp>Dans une applet :</imp> permet ainsi d'embarquer le processeur 
       XSL dans une applet et de récupérer le document de sortie sous forme 
       d'une chaîne de caractères.</item>
     </list>

     <p>Pour finir, Xalan fournit une interface de débuggage.</p>

    </sect>

    <sect><title>Saxon</title>

     <list>
      <item><link url="http://users.iclway.co.uk/mhkay/saxon"/></item>
      <item><link url="http://www.mozilla.org/MPL/"/></item>
     </list>

     <p>Saxon est un ensemble d'outils pour traiter les fichiers XML. Il 
      comporte en particulier un processeur XSLT conforme au standard du 
      W3C, ainsi qu'une bibliothèque Java rendant un service comparable à
      XSLT mais avec la possibilité de programmer - ce qui permet par 
      exemple d'accéder à une base de données. Il utilise une version 
      modifiée de Ælfred (passant les commentaires à l'application), mais
      tout analyseur SAX 2 fait l'affaire.</p>

     <p>Le processeur XSLT de Saxon permet de générer plusieurs documents
      à partir d'un seul fichier XML, de chaîner les feuilles de style à
      appliquer au document XML et de modifier les variables d'une feuille
      de style (qui ne peuvent normalement pas être modifiées, contrairement
      à ce que laisse supposer leur nom).</p>

    </sect>

    <sect><title>XSL:P de Keith Visco</title>
     <list>
      <item><link url="http://www.clc-marketing.com/xslp/"/></item>
      <item><link url="http://www.clc-marketing.com/xslp/download.html"/></item>
     </list>

     <p>XSL:P fait maintenant partie du projet <file>xml.apache.org</file>. Il 
      n'implante que le <file>draft</file> du 21.4.1999. (et n'est donc pas à 
      jour par rapport au standard). Une version C++ est en développement 
      (elle est présente sur le <link url="http://lxr.mozilla.org/seamonkey/source/extensions/transformiix"/>).</p>

     <p>XSL:P peut utiliser XML4j versions 1.1.16 ou 2.0.x, OpenXML, 
      Oracle XML Parser ou ProjectX. Il est configuré par défaut pour utiliser 
      XML4J, mais on peut changer de parser en éditant le fichier 
      <file>xslp.properties</file> dans le fichier JAR.</p>

     <p>L'originalité de XSL:P est de disposer de <file>formatters</file> 
      permettant des formats de sortie divers.</p>

     <p>XSL:P soufre d'un problème de lenteur du à l'utilisation de DOM comme 
      format de représentation en mémoire des documents.</p>

     <p>L'auteur semble envisager de fusionner XSL:P dans Xalan.</p>

    </sect>
   </sect>

   <sect><title>Éditeurs XML</title>

    <p>Il est possible d'éditer un document XML avec tout éditeur de texte. 
     Cependant, il peut être utile de disposer d'un outil permettant de 
     valider les documents, de connaître les éléments autorisés, etc.</p>

    <sect><title>Emacs et PSGML</title>
     <list>
      <item><link url="http://www.emacs.org"/> et <link url="http://www.lysator.liu.se/projects/about_psgml.html"/></item>
      <item>Licence <link url="http://www.gnu.org/copyleft/gpl.html"/></item>
     </list>

     <p>On ne présente plus Emacs, l'éditeur surpuissant. On peut
      quasiment tout faire avec (lire son courrier, les forums, éditer
      du code Java, ou même des fichiers XML, comme je suis en train
      de le faire en ce moment même).</p>

     <p>Emacs possède par défaut un mode SGML adapté à XML, mais ce
      mode est assez limité. Pour un usage intensif, on lui préférera
      <file>PSGML</file>, mode permettant d'éditer des fichiers SGML et
      (depuis sa version 1.2.0) des fichiers XML.</p>

     <p>On peut trouver une documentation, en français, sur l'installation 
      de <file>PSGML</file> à l'adresse <link url="http://www.linux-france.org/article/appli/emacs/psgml-linuxdoc/sgml-tools-1/"/> (Attention ! cette 
      documentation n'est plus à jour mais reste utile). La documentation du
      programme est assez complète, mais on peut trouver un livre complet
      sur l'utilisation de <file>PSGML</file> à l'adresse <link url="http://www.snee.com/bob/sgmlfree"/>.</p>

     <p>On notera qu'il est nécessaire de taper <code>M-X xml-mode</code> pour
      éditer un fichier XML (sans quoi on l'édite en mode SGML, ce qui peut
      poser des problèmes). Il est aussi possible d'ajouter le commentaire
      suivant en fin de fichier pour passer au mode XML lors du chargement
      du fichier :</p>

<source>  &lt;!--
  Local Variables:
    mode: xml
    sgml-indent-data: t
    sgml-indent-step: 1
  End:
  --&gt;</source>
     
    </sect>

    <sect><title>XED</title>
     <list>
      <item>
       <link url="ftp://ftp.cogsci.ed.ac.uk/pub/ht/xed05-freebsd.tar.gz"/>
      </item>
      <item>Pour évaluation seulement</item>
     </list>

     <p>XED est un éditeur validant (il lit les DTDs) codé en C,
      Python et Tk. Il facilite l'édition des fichiers XML (messages
      d'erreur, possibilité d'enlever les instructions et les
      commentaires, menu contextuel pour les éléments et attributs,
      etc.).</p>

     <p>La principale limitation de XED vient de l'utilisation de Python
      qui ne supporte pas l'UNICODE.</p>
    </sect>

    <sect><title>Morphon XML Editor</title>
     <list>
      <item><link url="http://www.morphon.com"/>
      </item>
      <item>Gratuit</item>
     </list>

     <p>XMLEditor est un éditeur XML écrit en Java. Il permet d'éditer 
      graphiquement un fichier XML (avec une vue de l'arbre et une vue
      WYSIWYG). On peut aussi voir le résultat de la page HTML générée.</p>

     <p>La version testée utilisait pour le formatage un langage qui était
      une <file>extension</file> du standard XSL (appelé <file>EXSL</file>). La 
      version actuelle utilise <file>CSS</file> et fournit un éditeur adéquat.
      On peut cependant se demander si le choix de XSLT n'aurait pas été
      plus judicieux.</p>
    </sect>

    <sect><title>XML Pro</title>
     <list>
      <item><link url="http://www.vervet.com"/></item>
      <item>Commercial (version d'évaluation disponible)</item>
     </list>

     <p>XML Pro est un éditeur XML commercial écrit en Java. Il présente
      une vue de l'arborescence du fichier dans laquelle il est possible
      d'insérer un élément, d'en supprimer, etc. Une VM 1.2 est nécessaire.</p>

     <p>Si la réalisation semble convenable, on regrettera l'absence d'un
      visualisateur (vers HTML par exemple) dans cet outil visuel. Les
      utilisateurs militants de Linux regretteront aussi que l'on nous
      impose le L&amp;F Windows !</p>

     <p>L'archive ne fournissant ni documentation, ni script de lancement
      (même pour Windows), on est bien embarrassé à l'installation du
      produit (on ne connaît pas la classe Java à invoquer !). Voici un 
      script de lancement pour système UNIX :</p>

     <source>
    #!/bin/sh
    XMLPRO_HOME=/usr/local/xmlpro
    export CLASSPATH=$XMLPRO_HOME/xmlpro.jar
    cd $XMLPRO_HOME
    java XMLPro
     </source>
    </sect>

   </sect>

   <sect><title>Navigateurs et serveurs XML</title>

    <p>Un navigateur XML permet de visualiser un fichier XML associé à une
     feuille de style (XSL, CSS ou autre). C'est un outil essentiel pour
     l'utilisation de XML à grande échelle sur l'internet et pourtant,
     les navigateurs XML opérationnels ne sont pas légion.</p>

    <sect><title>InDelv XML Browser</title>
     <list>
      <item><link url="http://www.indelv.com"/></item>
      <item>Gratuit</item>
     </list>

     <p>La version de test de ce produit comporte un éditeur en version
      limitée dans le temps et un navigateur XML/XSL gratuit.</p>

     <p>L'ensemble est intéressant et plutôt stable. Le choix d'AWT peut 
      être critiqué, mais il donne au programme une vitesse d'exécution
      très satisfaisante.</p>

     <p>De nombreux fichiers d'exemples (dont les oeuvres de Shakespeare)
      sont fournis, et on prend alors conscience de la puissance du 
      concept : le navigateur charge les fichiers XML qui sont <file>tous</file>
      mis en forme avec la même feuille de style XSL <file>spécifique</file> aux 
      oeuvres de l'auteur.</p>

     <p>Si le concept est très intéressant, le rendu graphique (et en 
      particulier les polices) laissent un peu à désirer et on est encore
      loin du rendu d'un navigateur HTML comme Netscape.</p>
    </sect>

    <sect><title>Amaya</title>
     <list>
      <item><link url="http://www.w3.org/Amaya"/></item>
      <item><link url="http://www.w3.org/Consortium/Legal/copyright-software-19980720.html"/></item>
     </list>

     <p>Amaya est le navigateur du W3C et permet de tester les nouveaux
      protocoles et formats de données. Il est disponible pour Windows et
      pour UNIX (un fichier RPM est disponible au téléchargement). Amaya
      comporte de plus un éditeur HTML/XHTML/MathML WYSIWYG gérant les
      feuilles de style CSS.</p>

     <p>En ce qui concerne XML, Amaya est capable d'afficher et d'éditer le
      XHTML et MathML. On peut en voir une démonstration sur 
      <link url="http://www.w3.org/Amaya/MathExamples.html"/>
      (mais il faut un navigateur capable d'afficher le MathML pour en 
      profiter !).</p>

     <p>L'affichage des graphiques vectoriels XML SVG (Scalable Vector 
      Graphics) est prévu pour une prochaine version.</p>
    </sect>

    <sect><title>Cocoon</title>

     <list>
      <item><link url="http://xml.apache.org/cocoon"/></item>
      <item><link url="http://xml.apache.org/cocoon/license.html"/>
      </item>
     </list>

     <p>Cocoon est une extension pour gérer le XML côté serveur.
      In nécessite un serveur HTTP muni d'un moteur de servlets
      (comme JServ ou Tomcat). Il permet :</p>

     <list>
      <item>Générer du HTML, XHTML, WML ou PDF à partir de fichiers
       XML.</item>
      <item>De servir du XML à des clients capables de l'afficher
       (lorsqu'on lui fournit une feuille de style adéquate).</item>
      <item>D'appliquer des feuilles de style en cascade.</item>
      <item>De changer la feuille de style en fonction du client.</item>
     </list>
 
     <p>Le but de Cocoon est de séparer la <file>création</file>, le 
      <file>traitement</file> et la <file>présentation</file> du contenu XML 
      d'un site, qui correspondent à des métiers distincts. En effet,
      le contenu des pages se trouve dans les fichiers XML, le
      traitement dans des balises XSP (jeu de balises associées à
      des traitements) et la présentation dans des feuilles de style
      XSL.</p>

     <p>Les créateurs de Cocoon voient un certain nombre de limitations
      à son utilisation :</p>

     <list>
      <item>Le langage de feuilles de style XSL est encore méconnu,
       mais cela devrait changer dans un futur proche.</item>
      <item>Les traitements mis en jeu lors du formatage XSL sont
       lourds et consomment donc des ressources importantes côté
       serveur. La résolution de ce problème passe par l'utilisation
       de navigateurs XML/XSL qui déporteront le traitement côté
       client (c'est déjà le cas avec IE5).</item>
     </list>

    </sect>

   </sect>

  </sect>

  <sect><title>Exemples de mise en oeuvre</title>

   <p>Pour conclure cet exposé, je vous propose l'étude d'exemples de
    mise en oeuvre de XML dans divers domaines d'application.</p>

   <sect><title>Génération de pages</title>

    <sect><title>WAP SDK In-Fusio</title>

     <p><link url="http://www.in-fusio.com"/> est une 
      société Bordelaise proposant des services de
      jeu sur téléphone mobile. Elle développe entre autre des jeux
      WAP reposant sur PHP. Pour accélérer le développement de tels
      jeux (qui comportent tous une procédure d'identification, de
      gestion des scores, etc.) In-Fusio a développé la plateforme
      serveur GameZilla qui offre ces services.</p>

     <p>Le WAP SDK permet aux développeurs de jeux d'accéder aux services
      de GameZilla mais aussi de rendre le code du jeu indépendant de
      la plateforme cible. En particulier, le WML des pages doit être
      adapté aux deux principaux navigateurs WML que l'on trouve sur
      les téléphones mobiles (Nokia et Phone.com) et traduites suivant
      la langue de l'utilisateur.</p>
     
     <p>Il est bien sûr possible de le faire dynamiquement en PHP mais
      cela imbrique la présentation et la logique du jeu (les templates 
      pour les différentes versions du WML sont noyés dans le code) et
      est gourmand en ressources (pour obtenir dynamiquement les
      messages traduits, il faut aller les chercher dans une base de
      données, ce qui peut impliquer plusieurs requêtes par page).</p>

     <p>À cette approche dynamique, nous avons préféré une approche
      statique:</p>

     <list>
      <item>Le code PHP est clairement séparé du WML (séparation de la
       logique de jeu et de la présentation).</item>
      <item>On applique une première feuille de style aux sources
       pour adapter le WML au navigateur du client.</item>
      <item>Une deuxième feuille de style traduit les références
       aux messages (de la forme <code>@{reference}</code> en messages
       dans la langue du client.</item>
     </list>

     <p>Le programme de jeu doit être accompagné d'un fichier XML
      contenant la traduction des messages et les noms des fichiers
      des images suivant leur taille (fichier de <file>ressources</file>).
      Il doit être aussi accompagné d'un descripteur indiquant les
      configurations supportées (navigateurs, langues et tailles
      d'images).</p>

     <p>Lors de la compilation, le compilateur du SDK génère N
      répertoires comportant les fichiers compilés. Un répertoire
      correspond à une configuration possible (par exemple, navigateur
      Nokia, français et grandes images).</p>

     <p>Prenons le cas d'une page d'accueil d'un jeu:</p>

      <source>  &lt;?xml version="1.0"?&gt;

  &lt;?php
  // reset fields
  $solution="";
  session_register("solution");
  $nb_attempts=0;
  session_register("nb_attempts");
  ?&gt;

  &lt;wml&gt;
   &lt;head&gt;
    &lt;meta http-equiv="Expires" content="Thu, 01 Dec 1994 16:00:00 GMT"/&gt;
    &lt;meta http-equiv="Cache-Control" content="no-cache, max-age=0"/&gt;
   &lt;/head&gt;
  
   &lt;card id="menu" title="@{title}"&gt;
    &lt;p align="center"&gt;&lt;img src="@{logo}" alt="@{title}"/&gt;&lt;/p&gt;
    &lt;menu&gt;
     &lt;item href="play.php"&gt;@{play}&lt;/item&gt;
     &lt;item href="rules.php"&gt;@{rules-title}&lt;/item&gt;
     &lt;item href="ranking.php"&gt;@{ranking}&lt;/item&gt;
    &lt;/menu&gt;
    &lt;quit&gt;@{quit}&lt;/quit&gt;
   &lt;/card&gt;
  &lt;/wml&gt;</source>

     <p>Cette page comporte les particularités suivantes:</p>

     <list>
      <item>Les guidelines du SDK imposent une séparation claire
       du code PHP et du WML.</item>
      <item>On remarque le présence de références du type <code>@{nom}</code>.
       Ce sont des références à des ressources dont la valeur dépend de
       la configuration.</item>
      <item>Certains éléments de la partie WML ne font pas partie
       de la norme. Ce sont des éléments propres au SDK In-Fusio qui
       seront ensuite transformés suivant le navigateur ciblé. C'est le
       cas par exemple de l'élément &lt;menu&gt; qui sera transformé suivant
       la plateforme cible.
      </item>
     </list>

     <p>Fichier pour la configuration <code>Phone.com/fr/petites images</code>:</p>

      <source>  &lt;?php
  include("../lib/gz_configuration.php");
  include("../lib/gz_tools.php");
  include("../lib/gz_database.mysql.php");
  include("../lib/gz_identification.php");
  include("../lib/gz_score.php");
  header("Content-type: text/vnd.wap.wml");
  echo '&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;';
  ?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"
                       "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;
  
  
  &lt;?php // reset fields
  $solution="";
  session_register("solution");
  $nb_attempts=0;
  session_register("nb_attempts");
  ?&gt;&lt;wml&gt;
   &lt;head&gt;
    &lt;meta http-equiv="Expires" content="Thu, 01 Dec 1994 16:00:00 GMT"/&gt;
    &lt;meta http-equiv="Cache-Control" content="no-cache, max-age=0"/&gt;
   &lt;/head&gt;
  
   &lt;card id="menu" title="L'âge du capitaine"&gt;
    &lt;p align="center"&gt;&lt;b&gt;L'âge du capitaine&lt;/b&gt;&lt;/p&gt;
    &lt;p align="center"&gt;&lt;img src="../../img/captain.small.wbmp" 
                           alt="L'âge du capitaine"/&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;select&gt;
     &lt;option onpick="play.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Jouer&lt;/option&gt;
     &lt;option onpick="rules.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Règles du jeu&lt;/option&gt;
     &lt;option onpick="ranking.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Scores&lt;/option&gt;
    &lt;/select&gt;&lt;/p&gt;
    &lt;do label="Quitter" type="accept"&gt;&lt;go href="index.php?
       &lt;?php echo session_name();?&gt;=&lt;?php echo session_id();?&gt;"/&gt;
    &lt;/do&gt;
   &lt;/card&gt;
  &lt;/wml&gt;
  &lt;?php
  //gz_done();
  ?&gt;</source>

     <p>Dans ce fichier, l'élément &lt;menu&gt; a été remplacé par &lt;select&gt;
      et les éléments &lt;item&gt; par des &lt;option&gt;. Les références à des
      ressources texte ont été remplacées par les messages en français
      et les références à des images par leur valeur pour les petites 
      images.</p>

     <p>Le fichier généré pour la configuration <code>phone.com/en/grandes
       images</code> est le suivant:</p>

      <source>  &lt;?php
  include("../lib/gz_configuration.php");
  include("../lib/gz_tools.php");
  include("../lib/gz_database.mysql.php");
  include("../lib/gz_identification.php");
  include("../lib/gz_score.php");
  header("Content-type: text/vnd.wap.wml");
  echo '&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;';
  ?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"
                       "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;
  
  
  &lt;?php // reset fields
  $solution="";
  session_register("solution");
  $nb_attempts=0;
  session_register("nb_attempts");
  ?&gt;&lt;wml&gt;
   &lt;head&gt;
    &lt;meta http-equiv="Expires" content="Thu, 01 Dec 1994 16:00:00 GMT"/&gt;
    &lt;meta http-equiv="Cache-Control" content="no-cache, max-age=0"/&gt;
   &lt;/head&gt;
  
   &lt;card id="menu" title="Age Of Captain"&gt;
    &lt;p align="center"&gt;
      &lt;img src="../../img/captain.big.wbmp" alt="Age Of Captain"/&gt;
    &lt;/p&gt;

    &lt;p&gt;&lt;a href="play.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Play&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href="rules.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Rules of the game&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href="ranking.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;High scores&lt;/a&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;a href="index.php?&lt;?php echo session_name();?&gt;=
       &lt;?php echo session_id();?&gt;"&gt;Quit&lt;/a&gt;&lt;/p&gt;
   &lt;/card&gt;
  &lt;/wml&gt;
  &lt;?php
  //gz_done();
  ?&gt;</source>

     <p>Dans ce fichier, l'élément &lt;menu&gt; a été remplacé par une
      liste d'éléments &lt;a href=""&gt;, les références à des
      ressources texte ont été remplacées par les messages en anglais
      et les références à des images par leur valeur pour les grandes
      images.</p>

     <p>Cette approche amène beaucoup de souplesse:</p>

     <list>
      <item>Si l'on souhaite ajouter une langue, il suffit de rajouter
       les entrées correspondantes dans le fichier de ressources et
       dans le descripteur.</item>
      <item>Si l'on souhaite supporter une nouvelle famille (ou version)
       de navigateur, il faut simplement écrire la feuille de style
       adéquate.</item>
     </list>

    </sect>

    <sect><title>Sites des Éditions O'Reilly</title>

     <sect><title>Pourquoi avoir choisi XML ?</title><p/></sect>

     <p>Le choix de XML nous a semblé le meilleur pour plusieurs raisons :</p>
     <list>
      <item>Le site est essentiellement un <file>catalogue</file> (pas exclusivement
       toutefois, cet article en témoigne). On est donc amené à gérer de
       nombreuses pages donc la mise en forme est identique (les pages
       des livres). Il est alors intéressant de dissocier le fond de la forme,
       afin que les éditeurs n'aient pas à faire du formatage HTML.</item>
      <item>Les pages se doivent de suivre la charte graphique de celles
       du site américain, qui est amenée à changer. Avec un site en HTML,
       la modification de cette charte demanderait à ce que <file>toutes</file>
       les pages du site soient modifiées manuellement (soit environ 300 
       pages à l'heure actuelle). Cela donnerait des sueurs froides à tout
       webmestre.</item>
      <item>La possibilité de validation des documents permet d'éviter
       certaines erreurs (d'omission en particulier).</item>
      <item>À chaque compilation, la syntaxe HTML et les liens
       de toutes les pages du site sont vérifiés. Nous avons donc
       l'assurance que le rendu est correct sur tout navigateur et qu'il
       n'existe aucun lien cassé.</item>
     </list>

    <sect><title>Choix techniques</title><p/></sect>

     <p>Les informations pouvant être raisonnablement mises à jour
      quotidiennement, nous avons opté pour une solution de 
      <file>compilation statique</file> des pages du site : les pages HTML sont
      générées à partir des sources XML puis envoyées au serveur.</p>

     <p>Il existe deux autres solutions :</p>
     <list>
      <item>Génération des pages par <file>servlets</file> : les fichiers
       html sont générées lorsqu'ils sont appelés. Cette méthode
       est indispensable lorsque les informations contenues dans les
       pages changent très fréquemment, les pages sont ainsi toujours à 
       jour. Le revers de la médaille est que cette méthode est gourmande
       en ressources CPU côté serveur.</item>
      <item>Génération des pages <file>par le navigateur</file> : elle a
       les avantages de la méthode précédente sans en avoir les 
       inconvénients. Cependant, les navigateurs ne sont pas encore
       capables de réaliser une transformation XSL de manière fiable.
       Il est donc préférable de s'en tenir pour le moment au HTML.
       Dans un futur plus ou moins proche, c'est une solution qui
       sera probablement envisageable.</item>
     </list>

    <sect><title>Architecture</title><p/></sect>

     <p>Le site est généré entièrement à chaque compilation (pour
      éviter des problèmes de dépendances) à partir d'une arborescence
      de fichiers XML. Les fichiers de même type sont placés dans le même
      répertoire. Les types de fichiers sont au nombre de six :</p>

     <list>
      <item><imp>Catalogue :</imp> ces fichiers présentent les ouvrages du
       catalogue. Chaque fichier (décrivant un livre) génère entre trois
       et six fichiers HTML (index, auteur, description, critiques,
       errata et exemples). Ces pages sont liées entre elles et aux pages
       des catégories (Java, Logiciels Libres, Perl, etc.).</item>
      <item><imp>Article :</imp> génère l'article sous forme HTML et place un résumé dans les pages de catégories adéquates.</item>
      <item><imp>brève :</imp> ces brèves sont intégrées à la page d'accueil
       du site et/ou à des pages de catégories.</item>
      <item><imp>club :</imp> génèrent les pages du 
       <link url="http://www.editions-oreilly.fr/club"/>.
      </item>
      <item><imp>infos :</imp> comme les brèves, mais en plus long et sans 
       date.</item>
     </list>

     <p>Les pages d'index (la page d'accueil et les pages des catégories)
      sont générées par des fichiers XSL appliqués sur l'index XML du site :
      un fichier XML regroupant tous les fichiers XML des sources. Il est
      ainsi possible de générer les listes des ouvrages classées par
      ordre alphabétique, la liste des brèves classées par date, etc.</p>

     <p>Ainsi, la page d'accueil regroupe des fragments de nombre de
      fichiers XML :</p>

     
     <figure url="java-xml.page-accueil.png" width="10">
      <title>Structure de la page d'accueil du site</title>
     </figure>
     
     <p>Les fichiers à l'origine des différentes zones de cette page sont les
      suivants :</p>
     <enum>
      <item>La liste des catégories est codée dans le fichier XSL qui
       génère la page d'accueil.</item>
      <item>Les brèves proviennent du répertoire <file>breves</file> des sources.
       Seules les brèves ayant <file>index</file> pour catégorie y sont
       intégrées.</item>
      <item>Les articles présentés sur cette page sont ceux marqués de
       l'élément &lt;nouveau/&gt;.</item>
      <item>Suivent des infos issues du répertoire <file>info</file> et de la
       catégorie <file>index</file>.</item>
      <item>Pour finir, la liste des nouveautés est générée à partir des
       fichiers du catalogue. Seuls les ouvrages dont les
       fiches sont marquées de l'élément &lt;nouveau/&gt; sont intégrées à
       cette page.</item>
     </enum>

     <p>Pour conclure, je dirais que XML permet de gérer un tel site de 
      manière rationnelle et en préservant les investissements des
      Éditions O'Reilly du fait que XML est un standard et donc à l'abri
      du bon vouloir d'un unique éditeur de logiciel.</p>

    </sect>

   </sect>

   <sect><title>Programmation d'applications modulaires</title>

    <p>L'idée de cette approche de la programmation est de charger un
     arbre de Beans à partir d'un fichier de configuration XML. on peut
     en effet assez facilement définir une syntaxe pour "mapper" des
     beans sur des éléments XML:</p>

    <list>
     <item>Lorsque le parser rencontre un élément <code>Foo</code>, il 
      instancie (en utilisant l'API d'introspection) un objet de
      la classe <code>Foo</code>.</item>
     <item>Le parser appelle ensuite les méthodes <code>setBar()</code>
      sur l'objet instancié pour tout attribut <code>Bar</code>.</item>
     <item>Tout objet instancié est ajouté à son parent (l'élément
      qui le contient) avec la méthode <code>add()</code>.</item>
    </list>

    <p>Par exemple, le fichier XML suivant:</p>

     <source>
&lt;?xml version="1.0"?&gt;

&lt;GrandPere Nom="Emile"&gt;
  &lt;Fils Nom="Bernard"/&gt;
  &lt;Fille Nom="Louise"&gt;
    &lt;PetitFils Nom="Marc" Age="10"/&gt;
  &lt;/Fille&gt;
&lt;/GrandPere&gt;</source>

    <p>Lors du parsing de ce fichier, le parser va réaliser les actions
     suivantes:</p>

    <list>
     <item>Instanciation d'un objet <code>GrandPere</code></item>
     <item>Appel de la méthode <code>setNom("Emile")</code></item>
     <item>Instanciation d'un objet <code>Fils</code></item>
     <item>Appel de la méthode <code>setNom("Bernard")</code></item>
     <item>Appel de la méthode <code>add(Fils)</code> sur l'objet
      <code>GrandPere</code></item>
     <item>etc...</item>
    </list>

   <p>On obtient en mémoire une structure du type:</p>

    
     <figure url="java-xml.bean-tree.png" width="10">
     <title>Arbre de beans en mémoire</title>
    </figure>

   <p>Cette approche est très utile dans la mesure où ce système
    permet une configuration simple du programme (il suffit de modifier
    le fichier XML, avec un simple éditeur ou un outil graphique
    dédié). D'autre part, il est très extensible: pour utiliser un
    nouveau type de bean, il suffit de le placer dans le CLASSPATH
    du programme, de placer son élément associé dans le fichier
    de configuration et le tour est joué !</p>

   <p>Cette approche commence à prendre une grande importance en
    programmation Java et il me semble que c'est maintenant un paradigme
    incontournable utilisé dans un nombre croissant d'applications
    récentes.</p>

   <p>Nous allons maintenant voir un certain nombre d'exemples de
    mise en oeuvre de cette approche:</p>

    <sect><title>Système de Log de GameZilla</title>

     <p>Les logs sont envoyés (par RMI) au serveur de log qui les empile 
      (pour rendre la main immédiatement au client). Les logs sont
      dépilés par un <file>Consumer</file> qui les envoie aux <file>tuyaux</file>
      pour filtrage et sérialisation. L'architecture d'un tuyau de
      log est la suivante:</p>

     
     <figure url="java-xml.log-server.png" width="10">
      <title>Architecture du serveur de logs de GameZilla</title>
     </figure>
     
     

     <p>Le filtre permet de sélectionner les logs à sérialiser dans ce canal
      de log. Les logs passent ensuite par les channels qui définissent
      un moyen de persistance (dans des fichiers, dans une BD, par mail
      ou sur la console).</p>

     <p>Pour configurer ce système, nous avons mis en oeuvre la technique
      de mapping XML/Beans exposée ci-dessus. Voici un exemple de fichier
      de configuration d'un tuyau de logs:</p>

      <source> &lt;pipe name="ExenInfos"&gt;

  &lt;filter&gt;
   &lt;and&gt;
    &lt;source name="ExenTFTPServerV1.0"/&gt;
    &lt;priority min="0" max="1"/&gt;
    &lt;not&gt;
     &lt;or&gt;
      &lt;type name="Request"/&gt;
      &lt;type name="TransferComplete"/&gt;
     &lt;/or&gt;
    &lt;/not&gt;
   &lt;/and&gt;
  &lt;/filter&gt;

  &lt;channels&gt;
   &lt;file name="/home/casa/tmp/exen-infos.xml" formatter="XmlFormatter"/&gt;
  &lt;/channels&gt;

 &lt;/pipe&gt;</source>

     <p>Ce fichier de configuration indique que:</p>

     <list>
      <item>On applique un filtre sélectionnant les logs dont la source
       est <file>ExenTFTPServerV1.0</file>, dont le priorité est comprise
       entre 0 et 1 et dont le type n'est ni <file>Request</file>, ni
       <file>TransferComplete</file>.</item>
      <item>Ils sont envoyés dans un fichier <file>exen-infos.xml</file>
       après avoir été formatés en XML.</item>
     </list>

     <p>L'arbre d'objets associés à un tuyau est construit à partir
      du fichier de configuration puis les logs y sont envoyés lors
      du fonctionnement du serveur. L'avantage de cette solution est que
      sa mise en oeuvre est relativement simple et il n'est pas
      nécessaire de développer un outil graphique dans la phase de
      développement.</p>

     <p>Pour la configuration à chaud, les fichiers sont envoyés
      à l'interface d'administration par RMI. Le serveur stoppe les
      threads de consommation de la pile de logs, construit l'arbre
      des tuyaux puis relance les threads.</p>

     <p>D'autre part, le système est facilement extensible car il
      suffit, pour ajouter un channel (SMS par exemple), de développer
      le bean correspondant (en implémentant une interface propre aux
      channels) , de le placer dans le CLASSPATH puis de changer le
      fichier de configuration.</p>

    </sect>

    <sect><title>Free Java Installer</title>

     <list>
      <item><link url="http://www.sweetohm.com/html/fiji.html"/></item>
      <item>Licence <link url="http://www.gnu.org/copyleft/gpl.html"/></item>
     </list>

     <p>Ce programme est un auto-installeur Java sous licence GPL.
      Il permet de construire un jar qui est un programme d'installation.
      Examinons un exemple de fichier de configuration:</p>

      <source>  &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;

  &lt;install jar="/tmp/fiji-0.4.jar"
           logo="lib/logo.gif"&gt;
  
      &lt;text title="FiJI"
            text="This program will install Fiji on\
                  your computer. Hit [|&gt;] to continue\
                  or [O] to abort installation."/&gt;
      &lt;license file="lib/LICENSE"/&gt;
      &lt;copy dir="tmp"
            property="fiji.home"
            defaults="Windows=c:\Fiji,Unix=/usr/local/fiji"&gt;
            &lt;filter file="bin/fiji" from="@HOME@" to="${fiji.home}"/&gt;
            &lt;filter file="bin/fiji.bat" from="@HOME@" to="${fiji.home}"/&gt;
      &lt;/copy&gt;
      &lt;link from="${fiji.home}/bin/fiji"
            to="/usr/local/bin"
            mandatory="no"/&gt;
      &lt;append file="c:\autoexec.bat"
              line="set PATH=%PATH%;${fiji.home}\bin"
              os="Windows"
              mandatory="no"/&gt;
      &lt;text title="Congratulation !"
            text="FiJI have been installed succesfully.\
                  Hit [O] to terminate this program."/&gt;
  &lt;/install&gt;</source>
     
     <p>Chacun des éléments de ce fichier correspond à une étape de
      cette installeur (une tâche):</p>

     
     <figure url="java-xml.fiji-1.png" width="10">
      <title>Écran d'acceuil</title>
     </figure>
     
     

     <p>Cet écran correspond à l'élément XML suivant:</p>

      <source>      &lt;text title="FiJI"
            text="This program will install Fiji on\
                  your computer. Hit [|&gt;] to continue\
                  or [O] to abort installation."/&gt;</source>
     
     <figure url="java-xml.fiji-2.png" width="10">
      <title>Écran de licence</title>
     </figure>

     <p>Celui-ci correspond au suivant:</p>

      <source>      &lt;license file="lib/LICENSE"/&gt;</source>

     <p>Lors de la construction de l'installeur, le fichier XML de
      configuration est parsé et l'arbre de beans (qui étendent la 
      classe <file>Task</file>) construit. Cet arbre est ensuite sérialisé
      dans le fichier jar qui constitue l'installeur.</p>

     <p>Lorsque l'installeur est lancé, il désérialise l'arbre des
      tâches et appelle la méthode <code>process</code> sur le bean 
      racine. Le fichier XML de configuration n'est plus nécessaire
      et n'est donc pas embarqué dans le fichier jar.</p>

     <p>Cette approche permet de rendre le programme extensible du
      fait que l'on peut programmer d'autres tâches. Pour les utiliser,
      il suffit de les placer dans le <file>CLASSPATH</file> et de les
      invoquer dans le fichier de configuration.</p>
  
    </sect>

    <p>Cette technique qui me semble extrèmement prometteuse est de plus
     en plus utilisée en programmation Java. On pourra en particulier
     étudier le fonctionnement du programme
     <link url="http://jakarta.apache.org/ant"/> qui repose
     sur le même principe.</p>
  
   </sect>

  </sect>

 </text>

</article><!--
Local Variables:
  mode: xml
  sgml-indent-data: t
  sgml-indent-step: 1
End:
-->
